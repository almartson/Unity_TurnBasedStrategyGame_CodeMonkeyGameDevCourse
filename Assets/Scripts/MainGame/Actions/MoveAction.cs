using System;
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// This concrete class, (derived from BaseAction), handles the execution of the MOVE Action (Animations, timers, stages of the animation / action itself - even if it is a chain of animations tied up to each other and triggered together, - etc) <br />
/// </summary>
[System.Serializable]
public class MoveAction : BaseAction
{
    #region Attributes

    [Tooltip("List of ALL intermediate Destinations (x, y, z) (note: can be seen as all the necessary 'STEPS'...) that form the PATH the Character is taking.\n These are the Positions (x, y, z) generated by the Pathfinding Algorithm, executed just before starting the 'MoveAction' itself (a.k.a.: the overloaded virtual abstract function: 'TakeAction' from the 'BaseAction' Class...).\n There can be a certain number of STEPS, that number depends on other Field-Parameter (and you can also customize it...),  called 'Pathfinding Multiplier'.")]
    [SerializeField]
    private List<Vector3> _positionList;
    
    
    /// <summary>
    /// Index of '_positionList': <br /> <br />
    /// The List of ALL intermediate Destinations (x, y, z) (note: can be seen as all the necessary 'STEPS'...) that form the PATH the Character is taking..
    /// </summary>
    private int _currentPositionIndexOfList;
    
    
    /// <summary>
    /// Current Target Position,... it is where the Character is trying to move to, in the Update() Method.
    /// </summary>
    private Vector3 _currentTargetPosition;
    
    
    [Tooltip("This value must be multiplied by the 'maxMoveDistance' Number of GridPositions the Player can Move (ever) to: \n\n Maximum (approximated) number of GridPositions / NodePath (i.e.: NODES) a Player can Move in a given Turn, (compared with the Pathfinding results).")]
    [SerializeField] 
    private int _pathFindingDistanceMultiplier = 10;
    
    
    // Movement:
    //
    [Tooltip("Speed when Translating the Character / Unit (walking, moving)")]
    [SerializeField] private float _moveSpeed = 4.0f;
    
    // Rotation:
    //
    [Tooltip("Speed when Rotating the Character / Unit (walking, moving)")]
    [SerializeField] private float _rotateSpeed = 10.0f;

    
    #region BaseParameters (INPUT) for calling this action as a GENERIC ACTION, with the function:  TakeAction

    /// <summary>
    /// BaseParameters (INPUT) for calling this action as a GENERIC ACTION, with the function:  TakeAction
    /// </summary>
    private MoveActionBaseParameters _moveActionBaseParameters = new MoveActionBaseParameters();
    

    #endregion BaseParameters (INPUT) for calling this action as a GENERIC ACTION, with the function:  TakeAction
    
    
    #region Animator & Animations

    /// <summary>
    /// CallBack Listener (Delegate Function) for executing when Starting the Animation.
    /// </summary>
    public event EventHandler OnStartMovingAnimation;
    
    /// <summary>
    /// CallBack Listener (Delegate Function) for executing when Stopping / Ending the Animation.
    /// </summary>
    public event EventHandler OnStopMovingAnimation;

    #endregion Animator & Animations
    
    
    #region Utils
    
    [Tooltip("The Tolerance number to accept that a value is = ZERO")]
    [SerializeField]
    private float _stoppingDistance = 0.1f;
    
    private float _sqrStoppingDistance = 0.1f;

    #endregion Utils
    
    
    #region Validations: Movement
    
    /// <summary>
    /// Max number of Grid Cells the character can move in one Turn.
    /// </summary>
    [SerializeField]
    private int _maxMoveDistance = 4;
    

    #endregion Validations: Movement
    
    
    #region A.I. - AI
    
    // /// <summary>
    // /// (DEFAULT VALUE of...) Cost "PER UNIT" of this ACTION, for any ENEMY A.I., in terms of (CURRENCY = ) 'Action Points' <br />
    // /// ...this value should be summed to any other values, to represent the TOTAL "WORTH" of Taking This ACTION  (vs.  "Not Taking It").
    // /// </summary>
    // [Tooltip("(DEFAULT VALUE of...) Cost \"PER UNIT\" of this ACTION, for any ENEMY A.I., in terms of (CURRENCY = ) 'Action Points'\n...this value should be summed to any other values, to represent the TOTAL \"WORTH\" of Taking This ACTION  (vs.  \"Not Taking It\").")]
    // [SerializeField]
    // protected int _AI_DEFAULT_UNITARY_ACTION_POINT_COST_VALUE_FOR_ANY_ENEMY_AI_TO_DECIDE_ON_THIS_ACTION = 10;

    #endregion A.I. - AI
    
    #endregion Attributes


    #region Unity Methods

    /// <summary>
    /// Awake is called before the Start calls round
    /// </summary>
    protected override void Awake()
    {
        // Execute the "Awake" of the (Abstract and Implemented here)
        // ..Parent of this class:
        //
        base.Awake();
        
        #region Utils
        
        // Done: Misc Optimization: Calculating the (accepted) Square Min Distance.
        // Todo: To put this inside a CONSTANTS Class... better yet: A ScriptableObject that works a 'MasterConstant System Manager' (a Constant of Constants) and is accessible as a NameOfScriptableObject.Instance.ConstantSheet._CONSTANT...  (I mean: a Service Provider - Singleton - structure). 
        //
        _sqrStoppingDistance = _stoppingDistance * _stoppingDistance;
        
        #endregion Utils
        
        
        // Initialize the Current Target Position (cached variable for performance, not filling out the Heap too much and thus avoiding to copy this Struct a million times, one per each frame, when the Character is moving...) 
        //
        _currentTargetPosition = new Vector3(0, 0, 0);

    }// End Awake


    /// <summary>
    /// Start is called before the first frame update
    /// </summary>



    /// <summary>
    /// Update is called once per frame
    /// </summary>
    private void Update()
    {
        // Check whether this "Action" is Active or Inactive:
        // Mutex flag check:...
        //
        if (!_isActive)
        {
            // Its DISABLED so...
            // End it here  (for THIS FRAME)
            //
            return;
        }
        
        // Update the Unit Movement (Walking...)
        //
        UpdateUnitMove();
    }

    
    #endregion Unity Methods
    

    #region My Custom Methods

    #region Stop all Movement Action & Animation
    
    /// <summary>
    /// Stops TakeAction() and Movement Animations.
    /// </summary>
    private void StopMoveAction()
    {
        // Invoke: STOP the Animation
        //
        OnStopMovingAnimation?.Invoke(this, EventArgs.Empty);

        
        // Set this "Action" as DISABLED
        // + We CALL our DELEGATE (which is on the PARENT-Base Class):  tells everyone that the 'TakeAction() Action' routine ENDED  +  Set this "Action" as DISABLED:
        //
        ActionComplete();
        
    }//End StopMoveAction()
    
    #endregion Stop all Movement Action & Animation
    
    
    /// <summary>
    /// Moves the Unit / Character to the specified (x, y, z) Position (Grid).
    /// </summary>
    public override void TakeAction(Action onMoveActionComplete)   
        //
        //   (GridPosition gridPosition /* Used in MoveAction, new approach => _moveActionBaseParameters.TargetGridPositionOfSelectedMovement */, Action onMoveActionComplete)
        //
    {
        // 1- Get the Input Base Parameters (for this function call):
        //
        GenerateInputParameters();
        
        
        // 2- Move
        
        //   2.1- Get the -> GridPositions
        //...to move to  (i.e.: target to move to, for each Frame):
        //
        //   Pathfinding Algorithm:
        //
        List<GridPosition> pathGridPositionList = Pathfinding.Instance.FindPath( _unit.GetGridPosition(), _moveActionBaseParameters.TargetGridPositionOfSelectedMovement, out int pathLength);
        
        
        //   2.2- Set the List of: (x, y, z) WorldPosition  Coordinates
        //
        //...using the PATHFINDING RESULTS:   ( 'gridPositionList' )
        //...based on a List of intermediate Steps (Vector3 (x, y, z)...) which are the Destinations of the MoveAction... a.k.a.: the "GridPosition"(s)  as Input.
        //
        _positionList = new List<Vector3>();
        //
        // {
        //     // Get the WorldPosition, based on a "GridPosition" as Input.
        //     //
        //     LevelGrid.Instance.GetWorldPosition(this._moveActionBaseParameters.TargetGridPositionOfSelectedMovement),
        // };
        //
        //   2.3- Re-Set the  '_currentPositionIndexOfList'
        //
        _currentPositionIndexOfList = 0;

        //    2.4- Add intermediate STEPS:  Vector3 positions  ... to the  Destination List  ( _positionList )
        //
        #region Original CodeMonkey Approach - Foreach

        // foreach (GridPosition pathGridPosition in pathGridPositionList)
        // {
        //     // Add the GridPosition (as a Vector3)  -> to the  Destination  List
        //     //
        //     _positionList.Add(LevelGrid.Instance.GetWorldPosition(pathGridPosition));
        //     
        // }// End foreach

        #endregion Original CodeMonkey Approach - Foreach

        #region AlMartson's Approach - For - Performance intended

        // Lenght of List<>
        //
        int pathGridPositionListLenght = pathGridPositionList.Count;
        //
        for (int i = 0; i < pathGridPositionListLenght; i++)
        {
            // Add a intermediate STEP to move to, a GridPosition (as a Vector3)  -> to the  Destination  List
            //
            _positionList.Add(LevelGrid.Instance.GetWorldPosition( pathGridPositionList[i] ));
            
        }// End for

        #endregion AlMartson's Approach - For - Performance intended


        // Invoke: 3D Animation START
        //
        OnStartMovingAnimation?.Invoke(this, EventArgs.Empty);
        
        
        // We CALL our DELEGATE (which is on the PARENT-Base Class):  tells everyone that the 'TakeAction() Action' routine BEGAN (...the ACTIVATION-part of it)   +   Set this "Action" as ENABLED (a mutex flag _isActive)
        //
        ActionStart( onMoveActionComplete );

    }//End TakeAction()
    
    
    /// <summary>
    /// Generic Method for generating the necessary Input Parameters that are used in the calling of
    /// ..the Function Call to the generic: 'TakeAction'
    /// This must be reimplemented / overriden in each Concrete (derived, child).
    /// We need inside this class: <code>GridPosition</code>
    /// </summary>
    public override void GenerateInputParameters()
    {
        // Generate:
        //
        // 1- TARGET GridPosition (i.e.: the Destination of the Movement...)
        //
        // Not working for ENEMY A.I.:  this._moveActionBaseParameters.TargetGridPositionOfSelectedMovement = UnitActionSystem.Instance.GetSelectedUnit().GetFinalGridPositionOfNextPlayersAction();
        //
        // Getting the "GridPosition" of the Target, regardless of the Team that is playing (CPU or Player's):
        //
        _moveActionBaseParameters.TargetGridPositionOfSelectedMovement =
            this._unit.GetFinalGridPositionOfNextPlayersAction();
        
    }//End GenerateInputParameters


    /// <summary>
    /// Moves the Unit / Character to the specified (x, y, z) Position (Grid).
    /// </summary>
    /// <param name="newTargetPosition"></param>
    /// <param name="onMoveActionComplete"></param>
    [Obsolete("This method is deprecated (because of architectural reasons, the new version is a more decoupled and generic one: 'TakeAction' in a BaseAction.cs Class). Use: 'public void TakeAction(GridPosition gridPosition)' instead", true)]
    public void Move(Vector3 newTargetPosition, Action onMoveActionComplete)
    {
        // Get the List of: (x, y, z) WorldPosition  Coordinates
        //
        //...based on a List of intermediate Steps (Vector3 (x, y, z)...) which are the Destinations of the MoveAction... a.k.a.: the "GridPosition"(s)  as Input.
        //
        _positionList = new List<Vector3>()
        {
            // Get the WorldPosition, based on a "GridPosition" as Input.
            //
            newTargetPosition,
        };
        //
        // Re-Set the  '_currentPositionIndexOfList'
        //
        _currentPositionIndexOfList = 0;
        
        // Set this "Action" as ENABLED
        // Set the (mutex) flag:
        //
        _isActive = true;
        
        
        // We CALL our DELEGATE:  tells everyone that the 'TakeAction() Action' routine ENDED:
        //
        this.onActionComplete = onMoveActionComplete;
    }
    
    /// <summary>
    /// Makes the Unit / Character to TakeAction.
    /// </summary>
    private void UpdateUnitMove()
    {
        // 0- Update Variables

        // Copy (to an auxiliary variable):  the current (temporary) Destination (Vector3) of the Movement:
        //
        _currentTargetPosition.Set(_positionList[ _currentPositionIndexOfList ].x, _positionList[ _currentPositionIndexOfList ].y, _positionList[ _currentPositionIndexOfList ].z);

        // Calculate the Vector3 of the DIRECTION of Movement:
        //
        Vector3 moveDirection = (_currentTargetPosition - transform.position).normalized;
        
        
        // 1- Rotation
        //
        RotateUnitUsingVector3SlerpApproach(moveDirection);
        

        // 2- Move
        // Calculate the Distance... to see how close or far
        // ...is the Mouse Pointer -> from -> The Unit we want to TakeAction().
        //
        if (Vector3.SqrMagnitude(transform.position - _currentTargetPosition) > _sqrStoppingDistance)
        {
            // TakeAction
            // 1- Translation:
            //
            transform.position += moveDirection * (_moveSpeed * Time.deltaTime);
        }
        else
        {

            // Update the  '_currentPositionIndexOfList'  Index on the List of (Target) Positions...
            //...so we can Move  (starting IN the NEXT frame):
            //...to the next Vector3 Position:
            //
            _currentPositionIndexOfList++;
            //
            // Validate the  '_currentPositionIndexOfList'  Index on the List of (Target) Positions...
            //
            if (_currentPositionIndexOfList >= _positionList.Count)
            {

                // Stop TakeAction() MoveAction + STOP ANIMATION:
                //
                StopMoveAction();

            }//End if (_currentPositionIndexOfList >= _positionList.Count)

        }//End else of if (Vector3.SqrMagnitude...

    }//End UpdateUnitMove()

    
    #region Rotation: LERP vs. SLERP 
    
    /// <summary>
    /// Quaternions + Spherical Interpolation, SLERP, (Quaternions behind the Scenes):
    ///...it rotates in a better way (first Rotates, then Walks):
    /// </summary>
    /// <param name="moveDirection"></param>
    private void RotateUnitUsingVector3SlerpApproach(Vector3 moveDirection)
    {
        
        // Quaternions + Spherical Interpolation, SLERP, (Quaternions behind the Scenes):
        //...it rotates in a better way (first Rotates, then Walks):
        //
        transform.forward = Vector3.Slerp(transform.forward, moveDirection, Time.deltaTime * _rotateSpeed);
    }
    
    /// <summary>
    /// Linear Interpolation, LERP: Original, CodeMonkey's: No Quaternions involved.
    ///...it rotates, but the SLERP option is way better
    ///...(LERP produces this effect: first walks backwards 1 or 2 steps, like Michael Jackson...
    ///...then Rotates, then Walks the rest...):
    /// </summary>
    /// <param name="moveDirection"></param>
    private void RotateUnitUsingVector3LerpApproach(Vector3 moveDirection)
    {
        // Linear Interpolation, LERP: Original, CodeMonkey's:
        //
        transform.forward = Vector3.Lerp(transform.forward, moveDirection, Time.deltaTime * _rotateSpeed);
    }
    
    #endregion  Rotation: LERP vs. SLERP

    
    #region Movement Validations

    // NOTE: Its real implementation: is on the Base Class: 'BaseAction'
    // /// <summary>
    // /// Tells you whether the user/Player's selection (Grid Position) is Valid to TakeAction to. It uses several criteria, such as: the Position must be unoccupied, must be inside the Grid System, etc. 
    // /// </summary>
    // /// <returns>True or False to: is the selected "GridPosition" Valid??</returns>
    // public bool IsValidActionGridPosition(GridPosition gridPosition)

    
    /// <summary>
    /// Get a List of the Valid places where the Unit/Character can TakeAction to (i.e.: GridPosition(s)).
    /// This method cycles through the squares/Grids...(using FOR )... to get a list of the valid ones.
    /// </summary>
    /// <returns>Valid (GridPosition(s)) places where the Unit/Character can TakeAction to, in this Turn.</returns>
    public override List<GridPosition> GetValidActionGridPositionList()
    {
        List<GridPosition> validGridPositionList = new List<GridPosition>();
        
        // Get the Unit's GridPosition.
        //
        GridPosition unitGridPosition = _unit.GetGridPosition();
        
        // Cycle through the Rows and Columns (Cells in general) to find the Valid ones for Moving() in.. in this Turn
        //
        for (int x = -_maxMoveDistance; x <= _maxMoveDistance; x++)
        {
            for (int z = -_maxMoveDistance; z <= _maxMoveDistance; z++)
            {
                // Create a GridPosition to Validate it:
                //
                GridPosition offsetGridPosition = new GridPosition(x, z);

                // All Actions are attached to an Unit, so we can get a reference to an Unit from this class/object and then from Unit to -> its Position / Grid.
                // Test a given GridPosition, moving it a little bit using the 'offsetGridPosition' (summing it, +), so we can Validate it:
                //
                GridPosition testGridPosition = unitGridPosition + offsetGridPosition;
                
                // Validation:
                //
                // 1- "GridPosition" Must be inside the Grid System, not off-limits:
                //
                if (!LevelGrid.Instance.IsValidGridPosition(testGridPosition))
                {
                    // Not Valid: continue / SKIP: to the NEXT ITERATION.
                    continue;
                }
                //
                // 2- "GridPosition" Must be different from the current one.
                //
                if (unitGridPosition == testGridPosition)
                {
                    // Not Valid: Same Grid Position where the Player / Unit is already at.
                    // Skip to next iteration:
                    //
                    continue;
                }
                //
                // 3- "GridPosition" Must NOT be previously occupied.
                //
                if (LevelGrid.Instance.HasAnyUnitOnGridPosition(testGridPosition))
                {
                    // Not Valid:
                    // Grid Position is already occupied with another Unit. Skip to next iteration:
                    //
                    continue;
                }
                //
                // 4- "NodePath (Pathfinding equivalent to: -> GridPosition)"  Must be:
                //   WALKABLE
                //...setting given by Pathfinding.
                //...thus we avoid GridPositions occupied by Walls, Columns and other Obstacles:
                //
                if (! Pathfinding.Instance.IsWalkableGridPosition(testGridPosition))
                {
                    // Not Valid:
                    // "NodePath (Pathfinding equivalent to: -> GridPosition)"  is NOT  WALKABLE. Skip to next iteration:
                    //
                    continue;
                }
                //
                // 5- "NodePath (Pathfinding equivalent to: -> GridPosition)"  Must NOT be:
                //   null
                //...setting given by Pathfinding.
                //...thus we avoid 'impossible to reach' GridPositions  (places in the Map that are surrounded by 4 walls, etc.):
                // Todo: Optimize this one: because it is executing the WHILE PATHFINDING ALGORITHM each time it reaches this line. It means we are executing the Pathfinding for each "almost valid" GridObject... in a 100x100 grid cell, it could mean (at least 50% of the Game Board): >= 5.000 Times !!!
                //
                // Todo: Solution:  Calculate JUST ONCE the Function: Pathfinding.Instance.ValidateFullPath   (it should contain and update the VARIABLES CORRESPONDING TO: .HasPath, .GetPathLength,  )
                //
                if (! Pathfinding.Instance.HasPath(unitGridPosition, testGridPosition))
                {
                    // Not Valid:
                    // "NodePath (Pathfinding equivalent to: -> GridPosition)"  Must NOT be:  null.  Skip to next iteration:
                    //
                    continue;
                }
                //
                // 6- "Path Length" (Pathfinding PATH TOTAL COST)  Must be under:
                //   maxMoveDistance * _pathFindingMultiplier
                //...setting given by Pathfinding.
                //...thus we avoid GridPositions that are too far away, so making the Movement UNJUST, and nonsensical (like for instance moving through 30 GridPosition(s) in just one Click, one Turn):
                // Todo: Optimize this one: because it is executing the WHILE PATHFINDING ALGORITHM each time it reaches this line. It means we are executing the Pathfinding for each "almost valid" GridObject... in a 100x100 grid cell, it could mean (at least 50% of the Game Board): >= 5.000 Times !!!  
                //
                if (Pathfinding.Instance.GetPathLength(unitGridPosition, testGridPosition) > (_maxMoveDistance * _pathFindingDistanceMultiplier))
                {
                    // Not Valid:
                    // Path length is too long.  Skip to next iteration:
                    //
                    continue;
                }
                
                // Finally, Conclusion: Add the Tested & Valid GridPosition to the Local VALID List
                //
                validGridPositionList.Add(testGridPosition);

            } // End for 2
        }//End for 1
    
        return validGridPositionList;
    }


    #endregion Movement Validations
    
    
    #region UI related utils

    // /// <summary>
    // /// (Base Concrete implementation of:) Gets this ACTION'S Name.
    // /// </summary>
    // /// <returns></returns>
    // public string GetActionNameByStrippingClassName()
    // {
    //     // AlMartsons' version:  Get the Class Name, but maybe it needs to be stripped from the rest of the word (e.g.: SpinAction... to just: TakeAction - remove 'TakeAction' -, etc.).
    //     //
    //     return GetType().Name;
    // }
    
    /// <summary>
    /// (Concrete implementation of:) Gets this ACTION'S Name.
    /// </summary>
    /// <returns></returns>
    public override string GetActionName()
    {
        // CodeMonkey' version:  Write a custom class Name (string) here:
        //
        return "Move";
    }
    
    #endregion UI related utils
    
    
     
    #region A.I. - AI

    #region 2- More Complex A.I. Approach, By AlMartson

    
    /// <summary>
    /// Given THIS concrete-particular <code>MoveAction : BaseAction</code> <br />
    /// (Calculates and then...):  Gets the BEST possible DATA - "Grid Position(s)" to execute THIS "A.I. ACTION": a MoveAction towards the Goal ( = a "GridPosition")<br />
    /// It uses Pathfinding to match 3 things, for each "GridPosition" <br />
    ///
    /// 1- Pathfinding's PATH towards a "Target" <br />
    /// 2- **Smallest H (value of PathFinding for that "NODE")** (and on the GOAL:  H = 0) <br />
    /// 3- ..It is **withing the Range** of the **VALID MOVES**   (i.e.: Valid  ***"GridPosition"***)  for that Unit, for ***MoveAction*** Enemy Action Data... <br />
    /// 
    /// THAT "A.I. ACTION" will be used to test it out in each "GridPosition", and we get the ASSOCIATED DATA TO TAKING THAT ACTION..., <br />
    /// </summary>
    /// <returns>The DATA of the BEST possible A.I. ACTION (BaseAction):  "EnemyAIActionData"... <br />,
    /// ...based on the ACTION POINTS VALUE of each Action / Possibility</returns>
    public EnemyAIActionData GetBestEnemyAIActionDataForMovingSimplyTowardsAGoal(GridPosition gridPosition)
    {

        // 0- Make a List of DATA of: "ENEMY A.I. ACTION"(s):
        //
        _enemyAIActionDataList = new List<EnemyAIActionData>();
        

        // 1- Get the -> GridPositions
        //...to move to  (i.e.: target to move to, for each Frame):
        //
        //   Pathfinding Algorithm:
        //
        List<GridPosition> pathGridPositionList = Pathfinding.Instance.FindPath( _unit.GetGridPosition(), gridPosition, out int pathLength);
        //
        // Lenght of the List
        //
        int pathGridPositionListLength = pathGridPositionList.Count;
        //
        // Cache variable for the Path's GridPositions:
        //
        GridPosition pathGridPositionThatIsFurthestAway = pathGridPositionList[0];
        int indexOfPathGridPositionThatIsFurthestAway = 0;
        //
        // We must start on the Pathfinding's GridPosition INDEX = 1, because ZERO (0) is where the "Unit" is (and it is NOT VALID, the VALIDATION would RETURN "FALSE"):
        //
        const int initialIndexOfPathGridPosition = 1;


        // Cycle through all the  "GridPosition"s  that are part of the "Path" (Pathfinding) for a "MoveAction",
        //..towards the destined "GridPosition".
        //
        for (int i = initialIndexOfPathGridPosition; i < pathGridPositionListLength; i++)
        {

            // We want to:
            // Validate each "GridPosition" that:
            //
            // 1- Is inside the "Pathfinding.Instance.FindPath(...)" returned List
            // 2- ..It is **within the Range** of the **VALID MOVES**   (i.e.: Valid  ***"GridPosition"***)  for that Unit, for ***MoveAction*** Enemy Action Data...
            // 3- Has the **Smallest H (value of PathFinding for that "NODE")** (and on the GOAL:  H = 0)
            //..OPTIONAL condition, to use instead of (3):  Has it a BIGGER INDEX value in the List<GridPosition> pathGridPositionList ??
            
            // Solution:
            
            // 1- Is inside the "Pathfinding.Instance.FindPath(...)" returned List:  ( pathGridPositionList[i] )

            // 2- Is it  "Within the Range" of the **VALID MOVES**?
            //
            if ( IsValidActionGridPosition( pathGridPositionList[i] ))
            {

                // 3- Has it a BIGGER INDEX value in the List<GridPosition> pathGridPositionList ??
                // ..(i.e.,translation to plain english:  it is further away... nearest to its "Destination").
                // Save the "GridPosition" with the SMALLEST "H":
                //
                // Save the  GridPosition
                //
                pathGridPositionThatIsFurthestAway = pathGridPositionList[i];
                
                // Save the Index in the List<GridPosition>
                //
                indexOfPathGridPositionThatIsFurthestAway = i;

            }//End if ( IsValidActionGridPosition( pathGridPositionList[i] ))
            else
            {
                // End the For-Loop, and get out of this block.
                //
                break;

            }//End else of if ( IsValidActionGridPosition( pathGridPositionList[i] ))
  
        }//End for

        #region Generate the  DATA  for:   ENEMY "A.I. MoveAction".
    

        // 2- Get the  DATA  for that "MoveAction"
        //
        EnemyAIActionData enemyAIActionData = GetEnemyAIActionDataForMovingSimplyTowardsAGoal( pathGridPositionThatIsFurthestAway, indexOfPathGridPositionThatIsFurthestAway );

        // 3- Add the ACTION to the LIST
        //
        _enemyAIActionDataList.Add(enemyAIActionData);


        #endregion Generate the  DATA  for:   ENEMY "A.I. MoveAction".

        
        // Final Step:
        // NOTE:  This is a copy of the structure of the other A.I. Algorithms created by the CodeMonkey... it could be deleted and refactored to just simply "return enemyAIActionData"... but I am leaving it here like this because the Algoritm might evolve in Complexity in the Future, so this approach (cosidering multiple options, and the "Best Solution") could be useful...
        // Check to see if it found   ANY Possible "Grid Positions" (Positional DATA)... where to TAKE THIS Action:
        //
        if (_enemyAIActionDataList.Count > 0)
        {
            
            // Final:
            // SORT the possible DATA ACTIONS... to get the BEST of the BEST,.. 
            //...to execute it FIRST!
            // Sorted based on "ActionValue":
            //
            _enemyAIActionDataList.Sort((EnemyAIActionData a, EnemyAIActionData b) => b.actionValue - a.actionValue);

            // Return THE BEST ONE:   i.e.: the one at Index: [0]
            //
            return _enemyAIActionDataList[0];

        }
        else
        {
            // There are  No possible ENEMY A.I. ACTIONS
            //
            return null;

        }//End else of if (enemyAIActionList.Count > 0)

    }// End GetBestEnemyAIActionDataForMovingSimplyTowardsAGoal
    
    
    /// <summary>
    /// (Calculates and...):  Gets the "A.I. ACTION" data ("Cost" Value, final, calculated "Points", to see if it's worth it...) that is possible in a given,  "Grid Position". <br />
    /// For the "MoveAction":   The A.I. will just try to set standard values for allowing the Enemy A.I. to MOVE ("MoveAction") to a selected "GridPosition".  <br />
    /// </summary>
    /// <param name="gridPosition"></param>
    /// <param name="initialAdditionalAIActionPointCostValueOfThisAction">_myAIFinalActionPointCostValueForAnyEnemyAIToDecideOnThisAction's INITIAL VALUE to add</param>
    /// <returns>A set of DATA  (note: specially the "Cost" of taking THIS ACTION...) for taking this selected ACTION.</returns>
    public EnemyAIActionData GetEnemyAIActionDataForMovingSimplyTowardsAGoal(GridPosition gridPosition, int initialAdditionalAIActionPointCostValueOfThisAction)
    {
        // We want the Player not to move "RANDOMLY", but TOWARDS the weakest Unit-Player of the "Player team" (to attack it and Win in a easier way...):

        // Process:
        //
        // 1- There are no "Shootable Targets" from the destined "GridPosition", but, to keep this version of the Algorithm consistent: we will assign a value of = 0.
        //
        int targetCountAtPosition = 0;
        //
        // Save the 'targetCountAtPosition'  as the 'Cost Multiplier' of this  "A.I. ACTION":
        //
        _myAIMultiplierActionPointCostValueForAnyEnemyAIToDecideOnThisAction = targetCountAtPosition;

        // 2- Use that number (from (1)) to calculate the  "WORTHINESS" of this ACTION (i.e.: the ACTION COST-VALUE):   MULTIPLY IT..!
        //
        //    2.2- Execute the "Base Action" routine:
        //
        EnemyAIActionData enemyAIActionData = base.GetEnemyAIActionData(gridPosition, initialAdditionalAIActionPointCostValueOfThisAction);
        

        // //////////////
        // // Show only when the WORTHINESS OF THIS ACTION surpasses the STANDARD REASON / VALUE (i.e.: 10):
        // //
        // if (enemyAIActionData.actionValue > this._AI_DEFAULT_UNITARY_ACTION_POINT_COST_VALUE_FOR_ANY_ENEMY_AI_TO_DECIDE_ON_THIS_ACTION)
        // {
        //     Debug.Log($"enemyAIActionData.actionValue = {enemyAIActionData.actionValue.ToString()} \n* At enemyAIActionData.gridPosition() = ( {enemyAIActionData.gridPosition.x.ToString()} , 0, {enemyAIActionData.gridPosition.z.ToString()} )");
        // }
        // //////////////
        
        // Return the final ENEMY A.I. DATA:
        //
        return enemyAIActionData;

    }// End GetEnemyAIActionDataForMovingSimplyTowardsAGoal

    #endregion 2- More Complex A.I. Approach, By AlMartson
    
    
    /// <summary>
    /// (Calculates and...):  Gets the "A.I. ACTION" data ("Cost" Value, final, calculated "Points", to see if it's worth it...) that is possible in a given,  "Grid Position". <br />
    /// For the "MoveAction":   The A.I. will prioritize "GridPositions" where it can Shoot multiple Targets from... <br />
    /// ...that means:  if "moving to" a certain "GridPosition" normally has a "VALUE" of "10.0f" Action Points,...
    /// ...but from that GridPosition it could shoot to TWO (2) TARGETS (i.e.: Players Characters/Units-...) <br />
    /// ...then this Algorithm would prioritize THAT "child of BaseAction", with THAT "ActionData"... (on that "GridPosition"). <br />
    /// </summary>
    /// <param name="gridPosition"></param>
    /// <param name="initialAdditionalAIActionPointCostValueOfThisAction">_myAIFinalActionPointCostValueForAnyEnemyAIToDecideOnThisAction's INITIAL VALUE to add</param>
    /// <returns>A set of DATA  (note: specially the "Cost" of taking THIS ACTION...) for taking this selected ACTION.</returns>
    public override EnemyAIActionData GetEnemyAIActionData(GridPosition gridPosition, int initialAdditionalAIActionPointCostValueOfThisAction)
    {
        // We want the Player not to move "RANDOMLY", but TOWARDS the weakest Unit-Player of the "Player team" (to attack it and Win in a easier way...):
        //
        // 1- TRY to FIND if there are any "SHOOTABLE" -> "UNIT-PLAYERS (i.e.: "Targets") in the given  "Grid Position"...
        // 2- Use that number of ""SHOOTABLE" -> "UNIT-PLAYERS (i.e.: "Targets")" (from (1)) to calculate the  "WORTHINESS" of this ACTION (i.e.: the ACTION COST-VALUE):
        //
        // Process:
        //
        // 1- TRY to FIND HOW MANY "SHOOTABLE" "Targets" ("UNIT-PLAYERS) are there, from that POSITION  (GridPosition):
        //
        int targetCountAtPosition = _unit.GetAction<ShootAction>().GetTargetCountAtPosition(gridPosition);
        //
        // Save the 'targetCountAtPosition'  as the 'Cost Multiplier' of this  "A.I. ACTION":
        //
        _myAIMultiplierActionPointCostValueForAnyEnemyAIToDecideOnThisAction = targetCountAtPosition;

        // 2- Use that number of ""SHOOTABLE" -> "UNIT-PLAYERS (i.e.: "Targets")" (from (1)) to calculate the  "WORTHINESS" of this ACTION (i.e.: the ACTION COST-VALUE):   MULTIPLY IT..!
        //
        //    2.2- Execute the "Base Action" routine:
        //
        EnemyAIActionData enemyAIActionData = base.GetEnemyAIActionData(gridPosition, 0);
        

        // //////////////
        // // Show only when the WORTHINESS OF THIS ACTION surpasses the STANDARD REASON / VALUE (i.e.: 10):
        // //
        // if (enemyAIActionData.actionValue > this._AI_DEFAULT_UNITARY_ACTION_POINT_COST_VALUE_FOR_ANY_ENEMY_AI_TO_DECIDE_ON_THIS_ACTION)
        // {
        //     Debug.Log($"enemyAIActionData.actionValue = {enemyAIActionData.actionValue.ToString()} \n* At enemyAIActionData.gridPosition() = ( {enemyAIActionData.gridPosition.x.ToString()} , 0, {enemyAIActionData.gridPosition.z.ToString()} )");
        // }
        // //////////////
        
        // Return the final ENEMY A.I. DATA:
        //
        return enemyAIActionData;

    }// End GetEnemyAIActionData

    
    #endregion A.I. - AI

    #endregion My Custom Methods

}//End Class MoveAction


/// <summary>
/// Concrete-particular Class (derived as a child of "BaseParameters") for the Input Parameters,
/// ..of every Function call to: 'TakeAction()'
/// </summary>
public class MoveActionBaseParameters : BaseParameters
{

    #region Attributes

    /// <summary>
    /// Destination-Target Position for this Movement, of the Player's Unit, in the Cells-Grid.
    /// </summary>
    private GridPosition _targetGridPositionOfSelectedMovement;
    //
    /// <summary>
    /// Property Accessor to Private Field "_targetGridPositionOfSelectedMovement": <br /><br />
    /// Destination-Target Position for this Movement, of the Player's Unit, in the Cells-Grid. <br />
    /// </summary>
    /// <value></value>
    public GridPosition TargetGridPositionOfSelectedMovement { get => _targetGridPositionOfSelectedMovement; set => _targetGridPositionOfSelectedMovement = value; }


    #endregion Attributes


    #region Methods



    #endregion Methods

}//End Class MoveActionBaseParameters
